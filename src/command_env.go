package main

import (
	"bytes"
	"gopkg.in/alecthomas/kingpin.v2"
	"path/filepath"
	"text/template"
)

const (
	environmentTemplate = `######################################
##   DO NOT EDIT THIS FILE          ##
##   Generated by tfconfig          ##
##   tfconfig {{.TfconfigVersion}}                ##
######################################

module "config" {
  source = "{{.ConfigModulePath}}"
}{{ if .MigrationPassed }}

locals {
  name        = "{{.ProjectName}}"
  domain      = "{{.ProjectDomain}}"
  git_repo    = "{{.GitRepo}}"
  aws_profile = "{{ if .Local }}{{.AwsProfile}}{{ else }}default{{ end }}"
}

terraform {
  backend "s3" {
    encrypt = true{{ if .Local }}
    profile = "{{.AwsProfile}}"{{ end }}
  }
}

provider "null" {
  version = "{{.NullProviderVersion}}"
}

provider "random" {
  version = "{{.RandomProviderVersion}}"
}

provider "template" {
  version = "{{.TemplateProviderVersion}}"
}

provider "dns" {
  version = "{{.DnsProviderVersion}}"
}

provider "aws" {
  region  = "${module.config.region}"
  version = "{{.AwsProviderVersion}}"{{ if .Local }}
  profile = "${local.aws_profile}"{{ end }}
}{{ end }}

`
)

type ProjectConfig struct {
	ConfigModulePath        string
	TfconfigVersion         string
	MigrationPassed         bool
	Local                   bool
	ProjectName             string
	ProjectDomain           string
	GitRepo                 string
	AwsProfile              string
	AwsProviderVersion      string
	NullProviderVersion     string
	RandomProviderVersion   string
	TemplateProviderVersion string
	DnsProviderVersion      string
}

type EnvironmentDotEnv struct {
	environment map[string]string
	project     map[string]string
}

type EnvCommand struct {
	app                   *App
	log                   *Log
	environment           string
	modulesPath           string
	modulesSource         string
	modulesPathAbs        string
	local                 bool
	migrationPassed       bool
	projectConfig         *ProjectConfig
	environmentConfigPath string
	projectConfigPath     string
	template              *template.Template
	dotEnvConfig          EnvironmentDotEnv
}

func ConfigureEnvCommand(a *App) {
	c := &EnvCommand{
		app: a,
		log: a.log,
	}
	cmd := a.cli.Command("env", "Switch Terraform project environment").
		PreAction(c.validate).
		Action(c.run)

	cmd.Arg("environment", "Environment name").
		Required().
		Envar(TerraformEnvVar).
		StringVar(&c.environment)

	cmd.Flag("local", "Generate environment.tf with AWS_PROFILE for local running").
		Default("false").
		Short('l').
		Envar(TerraformLocalEnvVar).
		BoolVar(&c.local)
}

func (c *EnvCommand) run(context *kingpin.ParseContext) error {
	c.modulesSource = GetFullPath(c.modulesPath, EnvironmentsDir, c.environment, ConfigModuleName)
	c.log.Info("Module source will be: '%s'", c.modulesSource)

	c.dotEnvConfig = EnvironmentDotEnv{
		environment: c.app.ReadDotEnv(c.environmentConfigPath),
		project:     c.app.ReadDotEnv(c.projectConfigPath),
	}

	c.projectConfig = c.dotEnvMapper(&c.dotEnvConfig)

	c.app.AskConfirmOrSkip(c.app.isCi)

	// TODO move under normalized path resolving
	if c.app.createOrPopulateFile(GetFullPath(c.app.projectPath, EnvironmentFile), c.executeTemplate(c.template, c.projectConfig)) {
		c.log.Info("Successfully generated: %s", filepath.Base(GetFullPath(c.app.projectPath, EnvironmentFile)))
	} else {
		c.log.ErrorF("I don't really know what exactly should be happen to cause that error ¯\\_(ツ)_/¯ ")
	}

	return nil
}

func (c *EnvCommand) validate(context *kingpin.ParseContext) error {
	c.template = c.app.ParseTemplate(environmentTemplate)

	c.app.ValidatePath()

	configFilePath := GetFullPath(c.app.projectPath, ConfigFile)

	c.log.ShowOpts("Config", configFilePath)
	if isExists, _ := ValidateFile(configFilePath); !isExists {
		c.log.ErrorFWithUsage("Configuration file '%s' does'nt exists", ConfigFile)
	}

	environmentConfig := GetFullPath(c.app.projectPath, EnvironmentFile)
	c.log.ShowOpts("Environment", environmentConfig)

	if err, isValid := ValidateEnvironment(c.environment); !isValid {
		c.log.ErrorFWithUsage(err)
	}

	// TODO move under normalized path resolving
	// TODO refactor modules shouldnt looking twice
	modulesAbsPath, isFoundModules := c.app.findModules(c.app.projectPath)
	if !isFoundModules {
		c.log.ErrorF("Cant find '%s' dir", ModulesDir)
	}
	c.modulesPathAbs = modulesAbsPath

	c.environmentConfigPath = filepath.Join(c.modulesPathAbs, EnvironmentsDir, c.environment, defaultEnvironmentConfig)
	c.log.ShowOpts("Environment config path", c.environmentConfigPath)
	if isExists, _ := ValidateFile(c.environmentConfigPath); !isExists {
		c.log.ErrorF("Environment config '%s' not exists", defaultEnvironmentConfig)
	}

	projectConfigPath, isFound := c.app.projectEnvironmentConfigResolver(defaultProjectConfig)
	if !isFound {
		c.log.ErrorF("Project config '%s' not exists", projectConfigPath)
	}
	c.projectConfigPath = projectConfigPath
	c.log.ShowOpts("Project environment config", c.projectConfigPath)

	if isExists, isWritable := ValidateFile(environmentConfig); isExists && isWritable {
		c.log.Warning("Environment file '%s' exists and will be overridden", EnvironmentFile)
	} else if isExists && !isWritable {
		c.log.ErrorF("Environment file '%s' exists, but dont have write permissions", EnvironmentFile)
	} else {
		c.log.Info("Environment file '%s' does'nt exists and will be created", EnvironmentFile)
	}

	// TODO modules shouldnt searching twice, see todo above
	modulesPath, isFoundModules := c.findModules(c.app.projectPath)
	if !isFoundModules {
		c.log.ErrorF("Cant find '%s' dir", ModulesDir)
	}

	c.modulesPath = modulesPath
	return nil
}

// TODO use app.FindModules
func (c *EnvCommand) findModules(path string) (modulesPath string, isFound bool) {
	for _, v := range listSearchPaths() {
		if c.app.FindFolder(GetFullPath(path, v), ModulesDir) {
			return v + ModulesDir, true
		}
	}
	return "", false
}

func (c *EnvCommand) executeTemplate(t *template.Template, config *ProjectConfig) string {
	buffer := new(bytes.Buffer)
	err := t.Execute(buffer, config)
	c.log.must(err)

	if p := buffer.String(); p != "" {
		return p
	}

	return ""
}

func (c *EnvCommand) dotEnvMapper(env *EnvironmentDotEnv) *ProjectConfig {
	return &ProjectConfig{
		ConfigModulePath:        c.modulesSource,
		TfconfigVersion:         Version,
		MigrationPassed:         c.app.BoolResolver(env.project["MIGRATED"]),
		Local:                   c.local,
		ProjectName:             env.project["NAME"],
		ProjectDomain:           env.project["DOMAIN"],
		GitRepo:                 env.project["GIT_REPO"],
		AwsProfile:              env.environment["TERRAFORM_AWS_PROFILE"],
		AwsProviderVersion:      env.environment["AWS_PROVIDER_VERSION"],
		NullProviderVersion:     env.environment["NULL_PROVIDER_VERSION"],
		RandomProviderVersion:   env.environment["RANDOM_PROVIDER_VERSION"],
		TemplateProviderVersion: env.environment["TEMPLATE_PROVIDER_VERSION"],
		DnsProviderVersion:      env.environment["DNS_PROVIDER_VERSION"],
	}
}
